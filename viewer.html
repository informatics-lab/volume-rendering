<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>

<script src="./three.min.js"></script>
<script type="text/javascript" src=	"./TrackballControls.js"></script>

<!-- first pass shaders -->

<script id="vertexShaderFirstPass" type="x-shader/x-vertex">
    varying vec3 worldSpaceCoords;
    void main(){
        //Set the world space coordinates of the back faces vertices as output.
        worldSpaceCoords = position + vec3(0.5, 0.5, 0.5); //move it from [-0.5;0.5] to [0,1]
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }
</script>

<script id="fragmentShaderFirstPass" type="x-shader/x-fragment">
    varying vec3 worldSpaceCoords;
    void main(){
        //The fragment's world space coordinates as fragment output.
        gl_FragColor = vec4( worldSpaceCoords.x , worldSpaceCoords.y, worldSpaceCoords.z, 1 );
    }
</script>


<!-- second pass shaders -->
<script id="vertexShaderSecondPass" type="x-shader/x-vertex">
	varying vec3 worldSpaceCoords;
	varying vec4 projectedCoords;
	
	void main()
	{
		worldSpaceCoords = (modelMatrix * vec4(position + vec3(0.5, 0.5, 0.5), 1.0 )).xyz;
		gl_Position = projectionMatrix *  modelViewMatrix * vec4( position, 1.0 );
		projectedCoords =  projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
	}
</script>

<script id="fragmentShaderSecondPass" type="x-shader/x-fragment">
    varying vec3 worldSpaceCoords;
    varying vec4 projectedCoords;

    uniform sampler2D firstPassTexture, dataTexture; //i.e. tex and cubeTex
    uniform float steps;
    uniform float alphaCorrection;

    const int MAX_STEPS = 512;
    ivec2 textureShape = textureSize(dataTexture);
    
    vec3 dataShape = vec3(4, 4, 4); // really this should be passed not hard coded

    vec3 getDatumColor(float datum) {
    	vec3 color = vec3(255, 255, 255);
    	return color;
    }

    float getDatumAlpha(float datum) {
    	return datum * alphaCorrection;
    }
 
    float sampleAs3DTexture(sampler2D tex, vec3 pos, vec3 dataShape, vec2 texShape) {
    	/* 
		A function to reference a 2D RGBA texture which contains tiles 3D array data.

		Tiling goes column, row, channel

		Args:
			* tex: texture of tiled data
			* pos: position of the datum
			* dataShape: the x,y,z shape of the data which has been tiled
			* texShape: the x,y dims of the tiles texture
    	*/
    	vec2 maxTiles = vec2(texShape.x / dataShape.x, texShape.y / dataShape.y);
    	float thisTileN = pos.z;
    	float tilesPerLayer = maxTiles.x * maxTiles.y;
    	float zTile = floor(thisTileN/tilesPerLayer);
    	float yTile = floor((thisTileN - (zTile * tilesPerLayer)) / maxTiles.x);
    	float xTile = mod((thisTileN - (zTile * tilesPerLayer)), maxTiles.x);
    	vec3 thisTile = vec3(xTile, yTile, zTile);

    	float datum;
    	if (thisTile.z == 0.0){
    		texture2D(tex, vec2(thisTile.x, thisTile.y)).r;
    	}else if (thisTile.z == 1.0){
 			texture2D(tex, vec2(thisTile.x, thisTile.y)).g;
    	}else if (thisTile.z == 2.0){
    		texture2D(tex, vec2(thisTile.x, thisTile.y)).b;
    	}else if (thisTile.z == 3.0){
			texture2D(tex, vec2(thisTile.x, thisTile.y)).a;
    	}

    	return datum;
    }

    vec4 getRGBAfromDataTex(sampler2D tex, vec3 pos, vec3 dataShape, vec2 texShape){
    	float datum = sampleAs3DTexture(tex, pos, dataShape, texShape);
    	vec3 color = getDatumColor(datum);
    	float alpha = getDatumAlpha(datum);

    	return vec4(color.xyz, alpha);
    }

    // max 2d size is 4096 x 4096

    void main( void ) {
	    //Transform the coordinates it from [-1;1] to [0;1]
	    vec2 firstPassTexCoord = vec2(((projectedCoords.x / projectedCoords.w) + 1.0 ) / 2.0,
					    ((projectedCoords.y / projectedCoords.w) + 1.0 ) / 2.0 );

	    //The back position is the world space position stored in the texture.
	    vec3 backPos = texture2D(firstPassTexture, firstPassTexCoord).xyz;

	    //The front position is the world space position of the second render pass.
	    vec3 frontPos = worldSpaceCoords;

	    //The direction from the front position to back position.
	    vec3 dir = backPos - frontPos;
	
	    float rayLength = length(dir);
	
	    //Calculate how long to increment in each step.
	    float delta = 1.0 / steps;

	    //The increment in each direction for each step.
	    vec3 deltaDirection = normalize(dir) * delta;
	    float deltaDirectionLength = length(deltaDirection);

	    //Start the ray casting from the front position.
	    vec3 currentPosition = frontPos;
	
	    //The color accumulator.
	    vec3 accumulatedColor = vec3(0.0);
	
	    //The alpha value accumulated so far.
	    float accumulatedAlpha = 0.0;
	
	    //How long has the ray travelled so far.
	    float accumulatedLength = 0.0;
	
	    //vec4 dataSample;
	    vec4 dataSample;

	    float alphaSample;

	    //Perform the ray marching iterations
	    for(int i = 0; i < MAX_STEPS; i++){
		    //Get the voxel intensity value from the 3D texture.	
		    dataSample = getRGBAfromDataTex(dataTexture, currentPosition, dataShape, textureShape);

		    //Perform the composition.
		    accumulatedColor += (1.0 - accumulatedAlpha) * dataSample.xyz * dataSample.a;
			//accumulatedColor += dataSample;

		    //Store the alpha accumulated so far.
		    accumulatedAlpha += dataSample.a;
		
		    //Advance the ray.
		    currentPosition += deltaDirection;
		    accumulatedLength += deltaDirectionLength;
				      
		    //If the length traversed is more than the ray length, or if the alpha accumulated reaches 1.0 then exit.
		    if(accumulatedLength >= rayLength || accumulatedAlpha >= 1.0 )
				break;
	    }
	    vec4 fragColor = vec4(accumulatedColor.x, accumulatedColor.y, accumulatedColor.z, accumulatedAlpha);
	    gl_FragColor = fragColor;
    }

</script>


<script src="viewer.js"></script>
</body>
</html>

